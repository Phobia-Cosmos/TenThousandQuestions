1. [[声音]]
# 2024.6.27

1. 怎么样用编程的方式学习音乐？

```
用编程的方式学习音乐是一个有趣且有效的方法，尤其是对于那些对编程和音乐都感兴趣的人。通过编程，你可以深入理解音乐理论、音频处理和音乐创作过程。以下是一些编程学习音乐的方法和工具：

### 1. 学习音乐理论和基础

#### 音高和音符
- 编写程序来生成不同频率的正弦波，从而理解音高和音符的关系。
- 编写代码来识别和转换音符，例如从C到G或从A到F#。

#### 节奏和时值
- 用编程来创建节拍器，理解不同的节拍和时值。
- 编写程序来生成不同的节奏模式，理解拍号和节奏型。

### 2. 使用音乐编程语言和框架

#### Sonic Pi
- Sonic Pi 是一个实时音乐编码环境，非常适合初学者。它使用简单的Ruby语法，可以用来创作音乐。
- 通过Sonic Pi学习基本的编程概念和音乐结构，如音高、节奏、合成和效果处理。

#### SuperCollider
- SuperCollider 是一个强大的音频合成环境，适合高级用户。它提供了丰富的声音合成和处理功能。
- 学习如何使用SuperCollider来创建复杂的声音合成、处理音频效果和实时音乐表演。

#### ChucK
- ChucK 是一种实时音频编程语言，特别适合实时音乐表演和音频处理。
- 通过ChucK学习声音合成、效果处理和音乐编程的概念。

### 3. 创建音乐生成算法

#### 算法作曲
- 编写算法来生成旋律、和弦进程和节奏。可以使用随机生成、马尔可夫链或其他算法。
- 学习如何利用算法创作音乐，并理解算法音乐的概念。

#### 音乐生成库
- 使用如Music21（Python库）来分析和生成音乐。它提供了丰富的音乐理论工具和数据处理功能。
- 编写代码来分析乐谱、生成旋律和和弦进程，并将结果可视化。

### 4. 音频处理和效果

#### 音频信号处理
- 学习如何使用编程语言（如Python或MATLAB）来处理音频信号。理解基本的音频处理技术，如滤波、FFT、卷积等。
- 编写代码来实现简单的音频效果，如回声、混响、均衡器等。

#### 实时音频处理
- 使用如Pure Data（Pd）或Max/MSP等图形化编程环境来创建和处理实时音频效果。
- 学习如何设计和实现实时音频处理系统。

### 5. 结合硬件

#### MIDI编程
- 学习如何使用MIDI协议，通过编程来控制硬件合成器和MIDI设备。
- 编写代码来生成和解析MIDI信号，实现MIDI控制和自动化。

#### 嵌入式音乐项目
- 使用Arduino或Raspberry Pi等嵌入式平台来创建音乐硬件项目，如MIDI控制器、电子乐器等。
- 学习如何结合硬件和软件来实现互动音乐项目。

### 示例代码

#### Sonic Pi 示例

	```ruby
use_bpm 120

live_loop :melody do
  play scale(:c4, :major).choose, release: 0.2
  sleep 0.5
end

live_loop :drums do
  sample :bd_haus, amp: 2
  sleep 1
end
	```

#### Python + Music21 示例

	```python
from music21 import stream, note, chord

# 创建一个新的乐谱
s = stream.Stream()

# 添加一个音符
n = note.Note('C4')
s.append(n)

# 添加一个和弦
c = chord.Chord(['E4', 'G4', 'B4'])
s.append(c)

# 显示乐谱
s.show('text')
	```

通过这些工具和方法，你可以用编程的方式深入学习音乐，理解音乐理论和音频处理的核心概念，并创作出自己的音乐作品。
```

2. 合成音乐软件工作时是cpu密集型还是io？

```
合成音乐软件工作时主要是**CPU密集型**的，但也会涉及一定的I/O操作。

### 为什么是CPU密集型

1. **音频处理和效果应用**：音乐合成软件需要实时处理大量的音频数据。这包括应用各种效果器（如混响、延迟、均衡等）、合成声音（如使用振荡器、滤波器等）、进行音频变换（如音高变化、时间拉伸等）。这些操作都需要大量的计算资源，尤其是在处理高采样率和高分辨率音频时。

2. **虚拟乐器和采样器**：很多音乐合成软件使用虚拟乐器和采样器，这些都需要复杂的计算来生成和处理声音。例如，物理建模合成、频率调制合成和加法合成等技术都需要大量的计算能力。

3. **实时性要求**：实时音频处理要求非常高的低延迟和快速响应，这对CPU的性能提出了很高的要求。任何延迟或计算不足都会导致音频卡顿或处理不完整，影响最终的音乐质量。

### I/O 操作

尽管合成音乐软件主要是CPU密集型的，但I/O操作也扮演了一定的角色：

1. **音频文件的读取和写入**：加载样本、导出成品音乐等操作需要从硬盘读取和写入音频文件。这些操作是I/O密集型的，但通常不会占用太多时间，因为现代硬盘和固态硬盘的速度很快。

2. **插件和库的加载**：许多音乐合成软件使用大量的插件和音频库，这些也需要从磁盘加载。这种操作在启动和加载项目时会涉及大量的I/O操作。

3. **实时音频流**：在录音和回放时，软件需要处理来自音频接口的实时音频流。这些操作需要有效的I/O处理，但更多的是依赖于音频接口和驱动程序的性能，而不是CPU。

### 总结

合成音乐软件工作时主要是CPU密集型的，因为音频处理、效果应用和虚拟乐器的运算都需要大量的计算资源。同时，I/O操作也不可忽视，特别是在加载和存储音频文件、插件和样本库时。但总的来说，CPU的性能是决定音乐合成软件表现的关键因素。
```

3. 如何用计算机分析出我的音色？声音在计算机内饰如何存储的？每个人都有音色，但是一句话会有不同的字和词组成，因此计算机的肯定也能识别不同的字和词吧？计算机可以选择不同的声音读不同的内容，所以波形记录的是音色+字的发音？所以可以分离出字和音色再随意组合？）字的发音是不会变的，我们在字的wave上施加音色wave就可以得到不同的声音？如何分离？一个人声音的本质特征是什么，因为一个人可以控制低沉和尖叫，这些都是频率的变换吧？那我假如得到了一个人低沉的声音，如何将他变成这个人的高音？

```txt
计算机分析你的音色以及处理和存储声音涉及多个步骤和技术。以下是一个大致的解释：

### 1. 声音的存储

声音在计算机中通常以数字信号的形式存储。这涉及以下步骤：

1. **采样**：将连续的声波（模拟信号）转换成离散的数字信号。采样率（如44.1 kHz）决定了每秒钟采样的次数。
2. **量化**：将每个采样点的幅度值转换为数字形式，通常使用16位或24位深度。

存储后的声音数据就是一系列代表声波振幅的数字。

### 2. 分析音色

音色是声音的独特质量，它由多种因素决定，包括频率成分、包络和谐波结构等。要分析音色，计算机可以使用以下方法：

1. **傅里叶变换（Fourier Transform）**：将时间域的信号转换到频率域，可以识别出声音的频率成分。
2. **短时傅里叶变换（STFT）**：将信号分成小段，分析每段的频率成分，捕捉时间上的变化。
3. **梅尔频率倒谱系数（MFCC）**：常用于语音识别，能有效提取音色特征。

### 3. 语音识别

语音识别系统可以将语音信号转换成文字。这涉及以下步骤：

1. **预处理**：去除背景噪音和不必要的频率。
2. **特征提取**：使用MFCC或其他技术提取有用的声音特征。
3. **模型训练**：使用机器学习模型（如HMM、DNN、RNN）训练语音识别模型。
4. **解码**：将特征向量转换成文字。

### 4. 声音合成

声音合成系统可以将文字转换成语音（TTS）。这涉及：

1. **文本分析**：分析输入的文字，分词、标注重音和韵律等。
2. **声学模型**：将文字特征映射到声学特征。
3. **波形生成**：根据声学特征生成音频波形。

### 5. 分离音色和发音

理论上可以尝试分离音色和字的发音，但这是一个复杂的问题。可以使用以下技术：

1. **音色转换（Voice Conversion）**：利用深度学习技术（如循环神经网络、生成对抗网络）将一个人的声音转换成另一个人的声音。
2. **语音分离（Voice Separation）**：从混合音频中分离出不同的声音源，这通常用于噪音消除或音乐分离。

### 6. 声音特征的变换

一个人可以控制声音的频率（如低音和高音），但声音的本质特征（如音色）在变换中应保持一致。将低沉的声音变成高音可以通过以下方法：

1. **改变音高（Pitch Shifting）**：使用信号处理技术（如PSOLA、WOLA）改变声音的音高，而不改变其他特征。
2. **语音合成技术**：根据音高变化重新生成声音。

### 示例：声音转换

假设我们有一个人的低沉声音，我们可以使用音高转换算法来提高音高，从而得到高音的效果。这通常涉及修改声音的频率成分，而保持其音色特征尽量不变。

总之，计算机通过复杂的信号处理和机器学习技术来分析、存储和转换声音，从而实现识别音色、分离字音和音色以及进行声音变换等功能。

```


4. pthread只能同一个线程acquire和release？

```
在多线程编程中，特别是使用POSIX线程（pthread）库时，线程同步是一个重要的概念。为了正确地管理共享资源，pthread提供了互斥锁（mutex）和信号量（semaphore）等同步机制。你的问题涉及线程对互斥锁的获取（acquire）和释放（release）规则。以下是关于pthread互斥锁的一些重要规则和概念：

### 互斥锁（Mutex）

1. **互斥锁的基本概念**
   - 互斥锁用于保护共享资源，确保在任何时刻只有一个线程能够访问该资源。
   - 当一个线程acquire（锁定）一个互斥锁时，其他试图锁定该互斥锁的线程将会阻塞，直到该互斥锁被release（解锁）。

2. **线程对互斥锁的获取和释放**
   - 互斥锁必须由相同的线程获取和释放。
   - 具体来说，如果线程A锁定了一个互斥锁（调用`pthread_mutex_lock`），则只有线程A可以解锁（调用`pthread_mutex_unlock`）该互斥锁。其他线程无法解锁这个互斥锁。
   - 这是为了防止在多线程环境中产生不可预测的行为和潜在的竞态条件。

### 示例代码

	```c
#include <pthread.h>
#include <stdio.h>

pthread_mutex_t lock;

void* thread_function(void* arg) {
    // 尝试获取互斥锁
    pthread_mutex_lock(&lock);
    printf("Thread %ld has acquired the lock\n", (long)arg);

    // 模拟一些工作
    sleep(1);

    // 释放互斥锁
    pthread_mutex_unlock(&lock);
    printf("Thread %ld has released the lock\n", (long)arg);

    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    // 初始化互斥锁
    pthread_mutex_init(&lock, NULL);

    // 创建两个线程
    pthread_create(&thread1, NULL, thread_function, (void*)1);
    pthread_create(&thread2, NULL, thread_function, (void*)2);

    // 等待线程完成
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    // 销毁互斥锁
    pthread_mutex_destroy(&lock);

    return 0;
}
	```

在上面的示例中，每个线程获取并释放相同的互斥锁。这保证了线程对共享资源的互斥访问。

### 递归互斥锁

POSIX标准还定义了一种递归互斥锁（recursive mutex），它允许同一线程多次锁定和解锁。递归互斥锁的行为如下：
- 一个线程可以多次锁定递归互斥锁。
- 每次锁定需要对应一个解锁操作。
- 递归互斥锁的初始化方式如下：

	```c
pthread_mutex_t recursive_lock;
pthread_mutexattr_t attr;

pthread_mutexattr_init(&attr);
pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutex_init(&recursive_lock, &attr);
pthread_mutexattr_destroy(&attr);
	```

### 结论

总之，标准的pthread互斥锁要求获取和释放必须由同一个线程执行。这是为了确保线程同步的正确性和安全性。如果需要同一线程多次锁定和解锁，可以使用递归互斥锁。了解和正确使用这些锁是编写线程安全代码的关键。
```

5. 信号量底层实现是什么？

```
信号量（Semaphore）是一种用于控制对共享资源访问的同步机制，广泛用于多线程编程。信号量的底层实现涉及操作系统内核提供的同步原语。以下是关于信号量底层实现的详细解释：

### 信号量的概念

信号量是一个整数，支持两种基本操作：

- **P（wait）操作**：减少信号量的值。如果信号量的值大于零，则减一；如果值为零，则阻塞直到信号量的值大于零。
- **V（signal）操作**：增加信号量的值。如果有其他进程或线程因为信号量值为零而阻塞，则唤醒其中一个。

信号量有两种类型：

- **计数信号量（Counting Semaphore）**：可以有多个资源的并发访问。
- **二进制信号量（Binary Semaphore）**：类似于互斥锁，只允许一个资源的访问。

### 信号量的底层实现

信号量的实现依赖于操作系统内核提供的同步机制，如锁、条件变量和调度器。以下是信号量的典型实现步骤：

#### 1. 数据结构

信号量通常由以下数据结构表示：

	```c
typedef struct {
    int value;             // 信号量的值
    pthread_mutex_t lock;  // 用于保护信号量值的互斥锁
    pthread_cond_t cond;   // 用于阻塞和唤醒等待线程的条件变量
} semaphore_t;
	```

#### 2. 初始化信号量

初始化信号量时设置初始值，并初始化互斥锁和条件变量：

	```c
void semaphore_init(semaphore_t *sem, int value) {
    sem->value = value;
    pthread_mutex_init(&sem->lock, NULL);
    pthread_cond_init(&sem->cond, NULL);
}
	```

#### 3. P（wait）操作

P操作减少信号量的值。如果信号量的值小于等于零，则当前线程阻塞：

	```c
void semaphore_wait(semaphore_t *sem) {
    pthread_mutex_lock(&sem->lock);
    while (sem->value <= 0) {
        pthread_cond_wait(&sem->cond, &sem->lock);
    }
    sem->value--;
    pthread_mutex_unlock(&sem->lock);
}
	```

#### 4. V（signal）操作

V操作增加信号量的值，并唤醒一个等待的线程（如果有）：

	```c
void semaphore_signal(semaphore_t *sem) {
    pthread_mutex_lock(&sem->lock);
    sem->value++;
    pthread_cond_signal(&sem->cond);
    pthread_mutex_unlock(&sem->lock);
}
	```

### 操作系统层面的实现

在操作系统层面，信号量的实现更加复杂，因为需要考虑进程调度、资源管理和多处理器同步。以下是操作系统如何实现信号量的一些关键点：

1. **原子操作**：信号量的P和V操作需要是原子的，以防止竞态条件。操作系统使用硬件提供的原子操作指令（如Test-and-Set、Compare-and-Swap）来实现这一点。
2. **调度器交互**：当线程因为信号量的值为零而阻塞时，调度器需要将该线程挂起，并将其放入等待队列。当信号量的值增加时，调度器需要将等待队列中的一个线程唤醒并重新调度。
3. **优先级处理**：在某些情况下，操作系统需要处理优先级反转的问题，即高优先级线程等待低优先级线程释放资源。操作系统可以使用优先级继承等机制来解决这个问题。

### 示例：Linux 内核中的信号量实现

在Linux内核中，信号量的实现使用了低级别的原子操作和等待队列。以下是简化的信号量实现概述：

	```c
typedef struct {
    atomic_t count;
    wait_queue_head_t wait;
} semaphore;

void down(semaphore *sem) {
    unsigned long flags;
    spin_lock_irqsave(&sem->wait.lock, flags);
    while (atomic_dec_return(&sem->count) < 0) {
        wait_event_interruptible(sem->wait, atomic_read(&sem->count) >= 0);
    }
    spin_unlock_irqrestore(&sem->wait.lock, flags);
}

void up(semaphore *sem) {
    if (atomic_inc_return(&sem->count) <= 0) {
        wake_up(&sem->wait);
    }
}
	```

在这个示例中，`down`函数对应P操作，`up`函数对应V操作。使用原子操作和等待队列来实现信号量的同步。

### 总结

信号量的底层实现依赖于操作系统提供的同步原语，如原子操作、互斥锁和条件变量。通过这些机制，信号量能够有效地控制对共享资源的访问，确保多线程或多进程环境中的同步和互斥。
```

6. 什么是二次型，就是多元函数吗？为什么要在线性代数中学习？正定又有什么用？还有负定等？

```
二次型（quadratic form）是一个在多元函数和线性代数中都有重要应用的概念。以下是详细解释：

### 二次型的定义

二次型是指一个二次多项式，其中每个项都是变量的二次幂或两个变量的乘积的形式。对于一个向量 \(\mathbf{x} = (x_1, x_2, \ldots, x_n)^T\)，二次型可以写成：

\[ Q(\mathbf{x}) = \mathbf{x}^T A \mathbf{x} \]

其中，\( \mathbf{x} \) 是 \( n \times 1 \) 的列向量，\( A \) 是 \( n \times n \) 的对称矩阵，即 \( A = A^T \)。

### 二次型在多元函数中的表现

在多元函数中，二次型表示的函数是关于这些变量的二次多项式。例如，对于二元函数 \( f(x, y) \)，一个二次型可能是：

\[ f(x, y) = ax^2 + bxy + cy^2 \]

其中 \( a \)、\( b \)、\( c \) 是常数。

### 二次型在线性代数中的学习

在线性代数中学习二次型有几个原因：

1. **矩阵和向量的表示**：二次型通过矩阵乘法来表示，能够帮助理解向量和矩阵之间的关系。
2. **特征值和特征向量**：二次型的性质与矩阵的特征值和特征向量密切相关。通过分析特征值，可以了解二次型的性质，如正定、负定等。
3. **应用广泛**：二次型在优化、经济学、物理学、统计学等多个领域有广泛的应用。例如，二次型常用于描述系统的能量、成本函数等。

### 正定、负定和半正定

- **正定（Positive Definite）**：一个对称矩阵 \( A \) 是正定的，如果对于所有非零向量 \( \mathbf{x} \)，有 \( \mathbf{x}^T A \mathbf{x} > 0 \)。正定矩阵对应的二次型总是正的。正定矩阵的重要性在于其定义一个严格凸的二次型函数，在优化问题中有独特的最小值。
  
- **负定（Negative Definite）**：一个对称矩阵 \( A \) 是负定的，如果对于所有非零向量 \( \mathbf{x} \)，有 \( \mathbf{x}^T A \mathbf{x} < 0 \)。负定矩阵对应的二次型总是负的。

- **半正定（Positive Semidefinite）**：一个对称矩阵 \( A \) 是半正定的，如果对于所有向量 \( \mathbf{x} \)，有 \( \mathbf{x}^T A \mathbf{x} \geq 0 \)。半正定矩阵对应的二次型非负。

- **半负定（Negative Semidefinite）**：一个对称矩阵 \( A \) 是半负定的，如果对于所有向量 \( \mathbf{x} \)，有 \( \mathbf{x}^T A \mathbf{x} \leq 0 \)。半负定矩阵对应的二次型非正。

### 二次型的实际应用

1. **优化问题**：在优化问题中，特别是二次规划问题中，目标函数通常是一个二次型。正定矩阵对应的二次型目标函数具有唯一的最小值。
2. **统计学**：在统计学中，协方差矩阵是一个半正定矩阵。二次型用于构造统计量，如卡方分布。
3. **物理学**：在物理学中，系统的能量函数通常是一个二次型。正定矩阵确保系统在平衡点附近是稳定的。
4. **经济学**：在经济学中，二次型用于描述效用函数和成本函数。正定矩阵对应的二次型函数表示凸成本或效用函数。

### 总结

二次型是一个在多元函数和线性代数中重要的概念。通过学习二次型，可以理解矩阵、向量和多元二次函数之间的关系。正定、负定和半正定等性质在优化、统计、物理和经济学等多个领域都有广泛的应用。通过分析二次型的性质，可以解决许多实际问题。
```

7. 为什么厕所蹲坑用久了以后上面会有一层黄色的物质？而且闻起来很刺鼻？如何消除这些物质以及在日常生活中如何避免产生他们？

```
厕所蹲坑上面形成的黄色物质通常是由尿液中的矿物质沉积、细菌生长和尿碱（尿酸盐）沉积引起的。以下是这种现象的详细原因及如何消除和预防的方法：

### 形成原因

1. **尿液中的矿物质沉积**：尿液中含有大量的矿物质，如尿酸、尿素、钙和磷酸盐等。这些矿物质会随着时间的推移沉积在蹲坑表面，形成黄色的污渍。

2. **尿碱（尿酸盐）**：尿液在暴露于空气中时，尿酸会分解并形成尿碱，这种物质容易附着在蹲坑表面，逐渐变成黄色。

3. **细菌和微生物的生长**：潮湿的环境为细菌和其他微生物提供了良好的生长条件，这些微生物与尿液中的成分相互作用，进一步加速黄色物质的形成，并产生刺鼻的气味。

### 消除方法

1. **使用酸性清洁剂**：酸性清洁剂，如醋、柠檬酸或专用的厕所清洁剂，可以有效地溶解尿碱和矿物质沉积物。使用方法如下：
   - 将清洁剂倒在黄色污渍上，静置一段时间（约30分钟到1小时）。
   - 用刷子刷洗污渍区域，然后用水冲洗干净。

2. **使用漂白剂**：漂白剂可以有效杀灭细菌和微生物，减少异味。
   - 将适量的漂白剂倒入蹲坑中，静置一段时间。
   - 用刷子刷洗，然后用水冲洗干净。

3. **使用小苏打和醋**：小苏打和醋的结合可以产生强力的清洁效果。
   - 在污渍区域撒上一些小苏打。
   - 倒入醋，产生泡沫后静置一段时间。
   - 用刷子刷洗，然后用水冲洗干净。

### 预防方法

1. **定期清洁**：定期清洁蹲坑是防止黄色物质积累的最有效方法。建议至少每周清洁一次。

2. **及时冲洗**：每次使用厕所后及时冲洗，可以减少尿液在表面停留的时间，防止矿物质和尿碱沉积。

3. **使用清洁剂**：在日常使用中，偶尔使用酸性清洁剂或厕所清洁剂进行维护，可以防止污渍的形成。

4. **保持通风**：保持厕所的通风，可以减少潮湿环境，抑制细菌和微生物的生长。

5. **安装防污装置**：一些厕所蹲坑设计有防污装置，可以减少尿液与表面的接触，防止污渍形成。

### 总结

黄色物质主要由尿液中的矿物质沉积、尿碱形成以及细菌和微生物的生长引起。通过使用酸性清洁剂、漂白剂、小苏打和醋等方法可以有效清除这些污渍。为了预防这些物质的形成，定期清洁、及时冲洗、保持通风以及使用适当的清洁剂和防污装置是有效的方法。
```
# 2024.6.28

1. 写一个自动化脚本，每天更新问题（我的一个文档路径为/Users/liuzihao/Desktop/Obsidian/Mac/日常/每日问题.md）后自动push到Github（只有更新后且过了晚上12才自动push），我也可以手动在任何时间push？你要给我脚本的代码以及如何去在Github上操作。
	1. 如何实现我在手机端修改文件后电脑也可以同步并将文件传到GitHub？

2. 最简单的声音驱动如何用代码实现？音频在计算机内存储的形式是一系列01，那你能否给我一串表示音频的01序列？如果我想使用这串01发出声音，我需要哪些硬件？假如我有一个内存条或者一组寄存器或者任何存储设备，我该如何将这串01写入这些存储设备？然后我该使用什么东西来将01转换为声音？我是否可以只有一个cpu然后其中的寄存器存储了音频文件，然后cpu通过总线直接连接外设，然后通电后cpu不断将数据输出到外设？对于mp3，其中只是存储了音频文件吧，里面并不存在cpu，当我们通电后他就可以向外输出数据？我们的耳机原理是什么？为什么连上mp3就可以有音乐听？以前的唱片机为什么放上唱片就可以放出不同的音乐？

3. 蓝牙的原理是什么？为什么可以不用线就可以传播数据？它使用的是什么物质进行传输的？我是否可以截获他认真在传输的数据？蓝牙应该是一种协议吧，如果我使用其中一方的密钥来进行截获我是否可以直接连上他人的设备？能发送蓝牙这种物质的设备是什么（硬件）？我能否通过一种方式来获取我身边正在使用蓝牙交换数据的设备的信息？也就是说我们得蓝牙耳机里面也是一个独一无二的设备？我们如何去修改这个设备的信息？如果说蓝牙是基于认证传输的，那么认证的凭证是什么？我应该是可以冒充一个设备的吧？

4. 也就是说我们的声音在进入计算机前已经被转换成了模拟信号是吗？那么声音的声波到模拟信号是如何实现的？

# 2024.7.2

1. tmpfs是如何由OS创建的？挂载又是什么意思？如何挂载？什么时候创建的？创建和挂载的代码是怎么样的？为什么OS会自动加载这个文件系统而不是其他文件系统，这个加载的选择配置文件在哪里可以看？

2. 什么是linux的根文件系统，难道除了根文件系统还有其他叶子文件系统？文件系统是以树形组织的？我可以删除某些文件系统吗？删除文件系统会影响我的硬件吗？删除后我该如何下载回来？文件系统存储在哪里的？
  
3. 文件系统是一个应用吗？文件系统如果是应用程序那又是如何启动的？是不是也要先load到内存中然后运行？运行的时候是常驻内存吗？ 🤌
  
4. 文件系统的类型定义也是在OS kernel中定义的吧？每一种文件系统类型的文件在存储介质上组织方式是事先规定好的吧（specification），而不是编码在内核代码的吧？🤌


              ext4文件系统是如何安装的？既然要注册到内核中，这个注册过程都做了什么？文件系统的卷是什么？这个ext4文件系统是作为外部文件还是kernel内部文件？如果说linux中存在ext4那我的Ubuntu服务器中怎么样可以看到他的相关代码？🤌

  

如何查看分区或存储设备上已有的卷？如何查看已有分区和存储设备？如何进行分区？对什么东西进行分区？在分区或设备上创建文件系统结构到底是在做什么，开辟一段内存或者外存空间？分区是个什么东西，在哪里？🤌

对于存储设备，除了块设备我们还有什么设备？如何查看我所有的存储设备？为什么要有块设备，是用来做什么的？块设备就是负责存储的吗？块设备的结构是什么，他是一个硬件还是软件数据结构？块设备是因为数据交换以块为单位而命名的吗？难道我就一定要以块为单位进行数据交换吗？如何使用命令查看我的ubuntu进行数据交换时是否是以块为单位的？

分区表？为什么不同的分区可能会使用不同的分区工具？分区只是在逻辑上进行划分吧，因为物理结构无法划分？那是不是我就不需要真实拥有一个存储设备而使用已有存储设备模拟新的存储设备并对其进行分区？这个分区就是在相应的数据结构中填补一系列属性值？

在kernel中，除了存储设备还有哪些种类的设备？是不是对于所有设备我们都存在驱动程序？

- lsblk输出结果解析：
	- lsblk输出的这些设备在内核中是以何种数据结构实现的？内核如何管理这些设备？设备的type只有这三种吗？lsblk对应的信息是如何使用syscall获得的？你可以帮我用c代码模拟一段类似的逻辑吗？也是获得这些信息？
	
	- 什么是伪设备以及我们为什么要使用伪设备？在内核中管理方式与其他设备有什么不同的吗？他的数据结构是什么？挂载的实际意义是什么？还有lsblk中loop设备的挂载的镜像文件是什么？为什么会有这么多的loop设备？如果我把loop设备删除会怎么样？
	
	- 为什么vda的类型是disk但是名字确实虚拟磁盘设备？我的这个机器是一台Ubuntu服务器。为什么我并没有进行过任何的分区操作，vda下面却会有三个分区？为什么有的vda分区有挂载点有的却没有？如果我把挂载点删除会怎么样？

	- 伪设备在内核中是如何被实现的？他是用了什么特殊的技术吗还是？你可以帮我简单模拟一个/dev/null吗？也就是说除了伪设备其他设备都是需要硬件支持的是吗？

	- 为什么我的服务器上没有/dev/sda而只有一个vda？我可以下载安装一个sda吗（注意我是购买的ubuntu服务器）

  

如何查看我的服务器上可以安装的所有文件系统？这些可以安装的文件系统都是通过mkfs相关命令安装吗？如果我想安装的文件系统并没有系统命令应该如何做？这些带有内置安装命令的文件系统的源代码是不是已经写在kernel中了？🤌

  

如果要安装的文件系统并未内置，我们下载下来源码并编译后，安装会被安装到哪里？我们的硬件存储设备上是吗？然后我们如果要使用它就在内核启动时加载这个模块，然后内核就可以按照该文件系统规定的方式使用对应的数据结构以及算法去管理文件是吗？🤌

  

              每种文件系统类型都有其规范（specification），规定了文件在存储介质上的组织方式，那这个规范是文档论文还是代码方式内嵌在各类文件系统的实现中？🤌

  

              我觉得kernel中对于文件系统的定义方式类似于一个总体定义，就是概括了所有文件系统应该怎么做（类似于java的抽象类），然后每一个具体的文件系统类型就是实现类，我这样理解有问题吗？不同的文件系统加载到内核中其实是指导kernel如何对磁盘文件进行读写操作吧，比如写到哪里以及怎么读是吗？

  

如果说文件系统作为动态加载的内核模块，也就是说我们可以去下载某种文件系统并将其设置在OS启动的文件中，让OS去加载这个文件系统是吗？

为什么OS会自动挂载根文件系统？如何配置让OS可以加载我们的文件系统？

文件系统和FCB的关系，操作系统如何找到文件目录项fcb？

可移植设备和系统引导分区（如 EFI 分区）？

blkid？

  

软件上的磁盘块区域划分在硬件上是如何转换表示的？逻辑和物理de ying she的映射是如何实现？如何在硬件上定位一比特？

  

索引块是一整块物理地址吗？如果用不完怎么办呢？物理地址是可以随机访问的吧？如何访问呢？

  

kernel中定义了哪些类型的设备？如果我想查看各种类型的设备，我该使用那些命令？

  

挂载：我当前根目录是ext4文件系统，为什么我要在某一个节点下挂载一个vda文件系统？挂载一个文件系统是不是就相当于扩展了实际的外存大小？
# 2024.7.5

1. 为什么要学习线性代数？线性代数中为什么要创建向量和矩阵？这个和高等数学有任何的关系吗？线性代数在实际中是如何应用的？如何和几何变换进行联系的？给定一个矩阵我该如何确定他是什么样的图形变换？行列式又是什么？为什么要创建行列式？行列式有何意义？为什么要对行列式进行计算？行列式如何计算呢？

2. 

## 定时任务

```sh
crontab -l
crontab -e
crontab -r
```